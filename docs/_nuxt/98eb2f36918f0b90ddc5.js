(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{157:function(e,n){e.exports={body:'# Searching\n\n\n## Sequential search\n\n\n```\nLIST = [2, 3, 5, 1, 5, 10, 13, 8]\nSEARCH = 2\nFOUND = false\n\nloop I from 0 to LIST.length()\n\tif LIST[I] == SEARCH then\n\t\tFOUND = true\n\t\toutput SEARCH, "found at position", I\n\tend if\nend loop\n\nif FOUND == false then\n\toutput "not found"\n```\n\n\n\n## Binary search\n\n```\nLIST = [1, 2, 4, 7, 10, 54, 55, 64, 345, 777, 787]\nSEARCH = 2\nSTART = 0\nEND = LIST.length()\n\nwhile START <= END\n//this is the recursive function\n\tMID = (START + END) div 2\n\tif LIST[MID] == SEARCH\n\t\toutput SEARCH, "found at position", MID\n\telse\n\t\tif SEARCH < LIST[MID]\n\t\t\tEND = MID - 1 //discarding middle element and everything after\n\t\telse\n\t\t\tSTART = MID + 1 //discarding middle element and everything before\n```\n\n\n\n<div class="responsive-table">\n<table>\n  <tr>\n   <td>Binary search\n   </td>\n   <td>Sequential search\n   </td>\n  </tr>\n  <tr>\n   <td>\n<ul>\n\n<li>Requires a sorted algorithm\n\n<li>More efficient for larger arrays\n\n<li>Time complexity = O(log n)\n</li>\n</ul>\n   </td>\n   <td>\n<ul>\n\n<li>Simplest search strategy; does not require array to be sorted\n\n<li>Relies on brute force strategy\n\n<li>Time complexity = O(n)\n</li>\n</ul>\n   </td>\n  </tr>\n</table>\n</div>\n\n\n# Sorting\n\n\n## Bubble sort\n\n```\nLIST = [2, 3, 5, 1, 5, 10, 13, 8]\n\nloop K from 0 to LIST.length() - 1\n\tloop I from 0 to LIST.length() - 2\n\t//-2 because the last element has no value after\n\t\tif LIST[I] > LIST[I+1] then\t\t\n\t\t\tswap(LIST[I], LIST[I+1])\n```\n\n\n\n## Selection sort\n\n```\nLIST = [2, 3, 5, 1, 5, 10, 13, 8]\n\nloop I from 0 to LIST.length()-2  //once done till n-2, n-1 will be sorted already\n\tMIN = I\n\t\n\tloop J from I+1 to LIST.length()-1\n\t     if LIST[I] < LIST[MIN]\n\t\t\tMIN = J\n\n\tswap(LIST[I], LIST[MIN])\n```\n\n\n\n\n\n<div class="responsive-table">\n<table>\n  <tr>\n   <td>Bubble sort\n   </td>\n   <td>Selection sort\n   </td>\n  </tr>\n  <tr>\n   <td>\n<ul>\n\n<li>Repeatedly steps through an array then compared and swaps adjacent elements if they are not in correct order\n\n<li>At the end of each pass, the highest number is bubbled up (end of array)\n\n<li>Takes multiple passes until no swaps are necessary\n\n<li>Slow and impractical\n\n<li>Time complexity = O(n<sup>2</sup>)\n</li>\n</ul>\n   </td>\n   <td>\n<ul>\n\n<li>Runs through the array and swaps the minimum value with the first value of the array\n\n<li>Time complexity = O(n<sup>2</sup>)\n</li>\n</ul>\n   </td>\n  </tr>\n</table>\n\n\n   </td>\n  </tr>\n  <tr>\n   <td>\n   </td>\n  </tr>\n</table>\n</div>\n\n\n\n\n# Stacks\n\n\n\n*   LIFO: last in, first out\n*   Top pointer points to first element: `PEEK() => STACK[TOP]`\n*   Two methods:\n    *   `PUSH()`\n    *   `POP()`\n\n\n## Applications\n\n\n\n*   Reversing a string\n*   Convert an infix expression to postfix\n\n\n## Methods\n\n\n### Push\n\n\n```\nTOP = -1  // stack is empty\ninput item\n\nif (TOP == N-1) then\n  print "OVERFLOW"\nelse\n  top = TOP + 1\n  STACK[TOP] = item\nend if\n```\n\n\n**Overflow** is when the stack is full and an element is being pushed.\n\n\n### Pop\n\n\n```\nTOP = 0  // no value for top as stack is empty\nif (TOP < 1) then\n  print "UNDERFLOW"\nelse\n  print STACK[TOP]\n  TOP = TOP -1\n  // return value and remove index\nend if\n```\n\n\n**Underflow** is when the stack is empty but an element is being popped.\n\n\n### Peek\n\n\n```\nbegin procedure PEEK\n  return stack[TOP]\nend procedure\n```\n\n\n\n# Queue\n\n\n\n*   FIFO: first in, first out\n    *   All **insertions** take place at the **rear**, and all **deletions** take place at the **front**\n*   Two pointers:\n    *   `FRONT` returns the first value\n    *   `REAR` returns the last value\n*   Top pointer points to first element: `PEEK() => QUEUE[FRONT]`\n*   Two methods:\n    *   `ENQUEUE()`\n    *   `DEQUE()`\n*   When a value is dequeued, the value of `FRONT()` changes, and there is a _vacant_ space left (and the value is returned)\n\n\n## Methods\n\n\n### Enqueue\n\n\n```\nbegin procedure ENQUEUE(DATA)\n  if QUEUE.isFull() then\n    return "OVERFLOW"\n    exit\n  end if\n  REAR = REAR + 1\n  QUEUE[REAR] = DATA\nend procedure\n```\n\n\n\n### Dequeue\n\n\n```\nbegin procedure DEQUEUE\n  if QUEUE.isEmpty() then\n    return "UNDERFLOW"\n    exit\n  end if\n  DATA = QUEUE[FRONT]\n  FRONT = FRONT + 1  \n  // the front value is changed\n  // although the data still exists in the memory, it is not in the queue\n  return DATA\nend procedure\n```\n\n\n\n### isFull\n\n\n```\nbegin procedure isFull\n  if (REAR == MAXSIZE) then  // max size is N - 1\n    return true\n  else\n    return false\n  end if\nend procedure\n```\n\n\n\n### isEmpty\n\n\n```\nbegin procedure isEmpty\n  if (FONT < MINSIZE) OR (FRONT > REAR) then\n    return true\n  else\n    return false\n  end if\nend procedure\n```\n\n\n\n### Peek\n\n\n```\nbegin procedure PEEK\n  return QUEUE[FRONT]\nend procedure\n```',html:'<h1>Searching</h1>\n<h2>Sequential search</h2>\n<pre><code>LIST = [2, 3, 5, 1, 5, 10, 13, 8]\nSEARCH = 2\nFOUND = false\n\nloop I from 0 to LIST.length()\n\tif LIST[I] == SEARCH then\n\t\tFOUND = true\n\t\toutput SEARCH, &quot;found at position&quot;, I\n\tend if\nend loop\n\nif FOUND == false then\n\toutput &quot;not found&quot;\n</code></pre>\n<h2>Binary search</h2>\n<pre><code>LIST = [1, 2, 4, 7, 10, 54, 55, 64, 345, 777, 787]\nSEARCH = 2\nSTART = 0\nEND = LIST.length()\n\nwhile START &lt;= END\n//this is the recursive function\n\tMID = (START + END) div 2\n\tif LIST[MID] == SEARCH\n\t\toutput SEARCH, &quot;found at position&quot;, MID\n\telse\n\t\tif SEARCH &lt; LIST[MID]\n\t\t\tEND = MID - 1 //discarding middle element and everything after\n\t\telse\n\t\t\tSTART = MID + 1 //discarding middle element and everything before\n</code></pre>\n<div class="responsive-table">\n<table>\n  <tr>\n   <td>Binary search\n   </td>\n   <td>Sequential search\n   </td>\n  </tr>\n  <tr>\n   <td>\n<ul>\n<li>Requires a sorted algorithm\n<li>More efficient for larger arrays\n<li>Time complexity = O(log n)\n</li>\n</ul>\n   </td>\n   <td>\n<ul>\n<li>Simplest search strategy; does not require array to be sorted\n<li>Relies on brute force strategy\n<li>Time complexity = O(n)\n</li>\n</ul>\n   </td>\n  </tr>\n</table>\n</div>\n<h1>Sorting</h1>\n<h2>Bubble sort</h2>\n<pre><code>LIST = [2, 3, 5, 1, 5, 10, 13, 8]\n\nloop K from 0 to LIST.length() - 1\n\tloop I from 0 to LIST.length() - 2\n\t//-2 because the last element has no value after\n\t\tif LIST[I] &gt; LIST[I+1] then\t\t\n\t\t\tswap(LIST[I], LIST[I+1])\n</code></pre>\n<h2>Selection sort</h2>\n<pre><code>LIST = [2, 3, 5, 1, 5, 10, 13, 8]\n\nloop I from 0 to LIST.length()-2  //once done till n-2, n-1 will be sorted already\n\tMIN = I\n\t\n\tloop J from I+1 to LIST.length()-1\n\t     if LIST[I] &lt; LIST[MIN]\n\t\t\tMIN = J\n\n\tswap(LIST[I], LIST[MIN])\n</code></pre>\n<div class="responsive-table">\n<table>\n  <tr>\n   <td>Bubble sort\n   </td>\n   <td>Selection sort\n   </td>\n  </tr>\n  <tr>\n   <td>\n<ul>\n<li>Repeatedly steps through an array then compared and swaps adjacent elements if they are not in correct order\n<li>At the end of each pass, the highest number is bubbled up (end of array)\n<li>Takes multiple passes until no swaps are necessary\n<li>Slow and impractical\n<li>Time complexity = O(n<sup>2</sup>)\n</li>\n</ul>\n   </td>\n   <td>\n<ul>\n<li>Runs through the array and swaps the minimum value with the first value of the array\n<li>Time complexity = O(n<sup>2</sup>)\n</li>\n</ul>\n   </td>\n  </tr>\n</table>\n   </td>\n  </tr>\n  <tr>\n   <td>\n   </td>\n  </tr>\n</table>\n</div>\n<h1>Stacks</h1>\n<ul>\n<li>LIFO: last in, first out</li>\n<li>Top pointer points to first element: <code>PEEK() =&gt; STACK[TOP]</code></li>\n<li>Two methods:\n<ul>\n<li><code>PUSH()</code></li>\n<li><code>POP()</code></li>\n</ul>\n</li>\n</ul>\n<h2>Applications</h2>\n<ul>\n<li>Reversing a string</li>\n<li>Convert an infix expression to postfix</li>\n</ul>\n<h2>Methods</h2>\n<h3>Push</h3>\n<pre><code>TOP = -1  // stack is empty\ninput item\n\nif (TOP == N-1) then\n  print &quot;OVERFLOW&quot;\nelse\n  top = TOP + 1\n  STACK[TOP] = item\nend if\n</code></pre>\n<p><strong>Overflow</strong> is when the stack is full and an element is being pushed.</p>\n<h3>Pop</h3>\n<pre><code>TOP = 0  // no value for top as stack is empty\nif (TOP &lt; 1) then\n  print &quot;UNDERFLOW&quot;\nelse\n  print STACK[TOP]\n  TOP = TOP -1\n  // return value and remove index\nend if\n</code></pre>\n<p><strong>Underflow</strong> is when the stack is empty but an element is being popped.</p>\n<h3>Peek</h3>\n<pre><code>begin procedure PEEK\n  return stack[TOP]\nend procedure\n</code></pre>\n<h1>Queue</h1>\n<ul>\n<li>FIFO: first in, first out\n<ul>\n<li>All <strong>insertions</strong> take place at the <strong>rear</strong>, and all <strong>deletions</strong> take place at the <strong>front</strong></li>\n</ul>\n</li>\n<li>Two pointers:\n<ul>\n<li><code>FRONT</code> returns the first value</li>\n<li><code>REAR</code> returns the last value</li>\n</ul>\n</li>\n<li>Top pointer points to first element: <code>PEEK() =&gt; QUEUE[FRONT]</code></li>\n<li>Two methods:\n<ul>\n<li><code>ENQUEUE()</code></li>\n<li><code>DEQUE()</code></li>\n</ul>\n</li>\n<li>When a value is dequeued, the value of <code>FRONT()</code> changes, and there is a <em>vacant</em> space left (and the value is returned)</li>\n</ul>\n<h2>Methods</h2>\n<h3>Enqueue</h3>\n<pre><code>begin procedure ENQUEUE(DATA)\n  if QUEUE.isFull() then\n    return &quot;OVERFLOW&quot;\n    exit\n  end if\n  REAR = REAR + 1\n  QUEUE[REAR] = DATA\nend procedure\n</code></pre>\n<h3>Dequeue</h3>\n<pre><code>begin procedure DEQUEUE\n  if QUEUE.isEmpty() then\n    return &quot;UNDERFLOW&quot;\n    exit\n  end if\n  DATA = QUEUE[FRONT]\n  FRONT = FRONT + 1  \n  // the front value is changed\n  // although the data still exists in the memory, it is not in the queue\n  return DATA\nend procedure\n</code></pre>\n<h3>isFull</h3>\n<pre><code>begin procedure isFull\n  if (REAR == MAXSIZE) then  // max size is N - 1\n    return true\n  else\n    return false\n  end if\nend procedure\n</code></pre>\n<h3>isEmpty</h3>\n<pre><code>begin procedure isEmpty\n  if (FONT &lt; MINSIZE) OR (FRONT &gt; REAR) then\n    return true\n  else\n    return false\n  end if\nend procedure\n</code></pre>\n<h3>Peek</h3>\n<pre><code>begin procedure PEEK\n  return QUEUE[FRONT]\nend procedure\n</code></pre>\n',attributes:{title:"Important algorithms",link:"important-algorithms",_meta:{resourcePath:"/Users/parthkabra/Documents/Code/Web/Nuxt/ib-notes/contents/pages/computer-science/important-algorithms.md"}},vue:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:'return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"dynamicMarkdown"},[_c(\'h1\',[_vm._v("Searching")]),_vm._v(" "),_c(\'h2\',[_vm._v("Sequential search")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("LIST = [2, 3, 5, 1, 5, 10, 13, 8]\\nSEARCH = 2\\nFOUND = false\\n\\nloop I from 0 to LIST.length()\\n\\tif LIST[I] == SEARCH then\\n\\t\\tFOUND = true\\n\\t\\toutput SEARCH, \\"found at position\\", I\\n\\tend if\\nend loop\\n\\nif FOUND == false then\\n\\toutput \\"not found\\"\\n")])]),_vm._v(" "),_c(\'h2\',[_vm._v("Binary search")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("LIST = [1, 2, 4, 7, 10, 54, 55, 64, 345, 777, 787]\\nSEARCH = 2\\nSTART = 0\\nEND = LIST.length()\\n\\nwhile START <= END\\n//this is the recursive function\\n\\tMID = (START + END) div 2\\n\\tif LIST[MID] == SEARCH\\n\\t\\toutput SEARCH, \\"found at position\\", MID\\n\\telse\\n\\t\\tif SEARCH < LIST[MID]\\n\\t\\t\\tEND = MID - 1 //discarding middle element and everything after\\n\\t\\telse\\n\\t\\t\\tSTART = MID + 1 //discarding middle element and everything before\\n")])]),_vm._v(" "),_c(\'div\',{staticClass:"responsive-table"},[_c(\'table\',[_c(\'tr\',[_c(\'td\',[_vm._v("Binary search\\n   ")]),_vm._v(" "),_c(\'td\',[_vm._v("Sequential search\\n   ")])]),_vm._v(" "),_c(\'tr\',[_c(\'td\',[_c(\'ul\',[_c(\'li\',[_vm._v("Requires a sorted algorithm\\n")]),_c(\'li\',[_vm._v("More efficient for larger arrays\\n")]),_c(\'li\',[_vm._v("Time complexity = O(log n)\\n")])])]),_vm._v(" "),_c(\'td\',[_c(\'ul\',[_c(\'li\',[_vm._v("Simplest search strategy; does not require array to be sorted\\n")]),_c(\'li\',[_vm._v("Relies on brute force strategy\\n")]),_c(\'li\',[_vm._v("Time complexity = O(n)\\n")])])])])])]),_vm._v(" "),_c(\'h1\',[_vm._v("Sorting")]),_vm._v(" "),_c(\'h2\',[_vm._v("Bubble sort")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("LIST = [2, 3, 5, 1, 5, 10, 13, 8]\\n\\nloop K from 0 to LIST.length() - 1\\n\\tloop I from 0 to LIST.length() - 2\\n\\t//-2 because the last element has no value after\\n\\t\\tif LIST[I] > LIST[I+1] then\\t\\t\\n\\t\\t\\tswap(LIST[I], LIST[I+1])\\n")])]),_vm._v(" "),_c(\'h2\',[_vm._v("Selection sort")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("LIST = [2, 3, 5, 1, 5, 10, 13, 8]\\n\\nloop I from 0 to LIST.length()-2  //once done till n-2, n-1 will be sorted already\\n\\tMIN = I\\n\\t\\n\\tloop J from I+1 to LIST.length()-1\\n\\t     if LIST[I] < LIST[MIN]\\n\\t\\t\\tMIN = J\\n\\n\\tswap(LIST[I], LIST[MIN])\\n")])]),_vm._v(" "),_c(\'div\',{staticClass:"responsive-table"},[_c(\'table\',[_c(\'tr\',[_c(\'td\',[_vm._v("Bubble sort\\n   ")]),_vm._v(" "),_c(\'td\',[_vm._v("Selection sort\\n   ")])]),_vm._v(" "),_c(\'tr\',[_c(\'td\',[_c(\'ul\',[_c(\'li\',[_vm._v("Repeatedly steps through an array then compared and swaps adjacent elements if they are not in correct order\\n")]),_c(\'li\',[_vm._v("At the end of each pass, the highest number is bubbled up (end of array)\\n")]),_c(\'li\',[_vm._v("Takes multiple passes until no swaps are necessary\\n")]),_c(\'li\',[_vm._v("Slow and impractical\\n")]),_c(\'li\',[_vm._v("Time complexity = O(n"),_c(\'sup\',[_vm._v("2")]),_vm._v(")\\n")])])]),_vm._v(" "),_c(\'td\',[_c(\'ul\',[_c(\'li\',[_vm._v("Runs through the array and swaps the minimum value with the first value of the array\\n")]),_c(\'li\',[_vm._v("Time complexity = O(n"),_c(\'sup\',[_vm._v("2")]),_vm._v(")\\n")])])])])]),_vm._v(" "),_c(\'tr\',[_c(\'td\')])]),_vm._v(" "),_c(\'h1\',[_vm._v("Stacks")]),_vm._v(" "),_c(\'ul\',[_c(\'li\',[_vm._v("LIFO: last in, first out")]),_vm._v(" "),_c(\'li\',[_vm._v("Top pointer points to first element: "),_c(\'code\',{pre:true},[_vm._v("PEEK() => STACK[TOP]")])]),_vm._v(" "),_c(\'li\',[_vm._v("Two methods:\\n"),_c(\'ul\',[_c(\'li\',[_c(\'code\',{pre:true},[_vm._v("PUSH()")])]),_vm._v(" "),_c(\'li\',[_c(\'code\',{pre:true},[_vm._v("POP()")])])])])]),_vm._v(" "),_c(\'h2\',[_vm._v("Applications")]),_vm._v(" "),_c(\'ul\',[_c(\'li\',[_vm._v("Reversing a string")]),_vm._v(" "),_c(\'li\',[_vm._v("Convert an infix expression to postfix")])]),_vm._v(" "),_c(\'h2\',[_vm._v("Methods")]),_vm._v(" "),_c(\'h3\',[_vm._v("Push")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("TOP = -1  // stack is empty\\ninput item\\n\\nif (TOP == N-1) then\\n  print \\"OVERFLOW\\"\\nelse\\n  top = TOP + 1\\n  STACK[TOP] = item\\nend if\\n")])]),_vm._v(" "),_c(\'p\',[_c(\'strong\',[_vm._v("Overflow")]),_vm._v(" is when the stack is full and an element is being pushed.")]),_vm._v(" "),_c(\'h3\',[_vm._v("Pop")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("TOP = 0  // no value for top as stack is empty\\nif (TOP < 1) then\\n  print \\"UNDERFLOW\\"\\nelse\\n  print STACK[TOP]\\n  TOP = TOP -1\\n  // return value and remove index\\nend if\\n")])]),_vm._v(" "),_c(\'p\',[_c(\'strong\',[_vm._v("Underflow")]),_vm._v(" is when the stack is empty but an element is being popped.")]),_vm._v(" "),_c(\'h3\',[_vm._v("Peek")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("begin procedure PEEK\\n  return stack[TOP]\\nend procedure\\n")])]),_vm._v(" "),_c(\'h1\',[_vm._v("Queue")]),_vm._v(" "),_c(\'ul\',[_c(\'li\',[_vm._v("FIFO: first in, first out\\n"),_c(\'ul\',[_c(\'li\',[_vm._v("All "),_c(\'strong\',[_vm._v("insertions")]),_vm._v(" take place at the "),_c(\'strong\',[_vm._v("rear")]),_vm._v(", and all "),_c(\'strong\',[_vm._v("deletions")]),_vm._v(" take place at the "),_c(\'strong\',[_vm._v("front")])])])]),_vm._v(" "),_c(\'li\',[_vm._v("Two pointers:\\n"),_c(\'ul\',[_c(\'li\',[_c(\'code\',{pre:true},[_vm._v("FRONT")]),_vm._v(" returns the first value")]),_vm._v(" "),_c(\'li\',[_c(\'code\',{pre:true},[_vm._v("REAR")]),_vm._v(" returns the last value")])])]),_vm._v(" "),_c(\'li\',[_vm._v("Top pointer points to first element: "),_c(\'code\',{pre:true},[_vm._v("PEEK() => QUEUE[FRONT]")])]),_vm._v(" "),_c(\'li\',[_vm._v("Two methods:\\n"),_c(\'ul\',[_c(\'li\',[_c(\'code\',{pre:true},[_vm._v("ENQUEUE()")])]),_vm._v(" "),_c(\'li\',[_c(\'code\',{pre:true},[_vm._v("DEQUE()")])])])]),_vm._v(" "),_c(\'li\',[_vm._v("When a value is dequeued, the value of "),_c(\'code\',{pre:true},[_vm._v("FRONT()")]),_vm._v(" changes, and there is a "),_c(\'em\',[_vm._v("vacant")]),_vm._v(" space left (and the value is returned)")])]),_vm._v(" "),_c(\'h2\',[_vm._v("Methods")]),_vm._v(" "),_c(\'h3\',[_vm._v("Enqueue")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("begin procedure ENQUEUE(DATA)\\n  if QUEUE.isFull() then\\n    return \\"OVERFLOW\\"\\n    exit\\n  end if\\n  REAR = REAR + 1\\n  QUEUE[REAR] = DATA\\nend procedure\\n")])]),_vm._v(" "),_c(\'h3\',[_vm._v("Dequeue")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("begin procedure DEQUEUE\\n  if QUEUE.isEmpty() then\\n    return \\"UNDERFLOW\\"\\n    exit\\n  end if\\n  DATA = QUEUE[FRONT]\\n  FRONT = FRONT + 1  \\n  // the front value is changed\\n  // although the data still exists in the memory, it is not in the queue\\n  return DATA\\nend procedure\\n")])]),_vm._v(" "),_c(\'h3\',[_vm._v("isFull")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("begin procedure isFull\\n  if (REAR == MAXSIZE) then  // max size is N - 1\\n    return true\\n  else\\n    return false\\n  end if\\nend procedure\\n")])]),_vm._v(" "),_c(\'h3\',[_vm._v("isEmpty")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("begin procedure isEmpty\\n  if (FONT < MINSIZE) OR (FRONT > REAR) then\\n    return true\\n  else\\n    return false\\n  end if\\nend procedure\\n")])]),_vm._v(" "),_c(\'h3\',[_vm._v("Peek")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("begin procedure PEEK\\n  return QUEUE[FRONT]\\nend procedure\\n")])])]) }]',component:{data:function(){return{templateRender:null}},render:function(e){return this.templateRender?this.templateRender():e("div","Rendering")},created:function(){this.templateRender=function(){var e=this.$createElement;this._self._c;return this._m(0)},this.$options.staticRenderFns=[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"dynamicMarkdown"},[t("h1",[e._v("Searching")]),e._v(" "),t("h2",[e._v("Sequential search")]),e._v(" "),t("pre",[t("code",{pre:!0},[e._v('LIST = [2, 3, 5, 1, 5, 10, 13, 8]\nSEARCH = 2\nFOUND = false\n\nloop I from 0 to LIST.length()\n\tif LIST[I] == SEARCH then\n\t\tFOUND = true\n\t\toutput SEARCH, "found at position", I\n\tend if\nend loop\n\nif FOUND == false then\n\toutput "not found"\n')])]),e._v(" "),t("h2",[e._v("Binary search")]),e._v(" "),t("pre",[t("code",{pre:!0},[e._v('LIST = [1, 2, 4, 7, 10, 54, 55, 64, 345, 777, 787]\nSEARCH = 2\nSTART = 0\nEND = LIST.length()\n\nwhile START <= END\n//this is the recursive function\n\tMID = (START + END) div 2\n\tif LIST[MID] == SEARCH\n\t\toutput SEARCH, "found at position", MID\n\telse\n\t\tif SEARCH < LIST[MID]\n\t\t\tEND = MID - 1 //discarding middle element and everything after\n\t\telse\n\t\t\tSTART = MID + 1 //discarding middle element and everything before\n')])]),e._v(" "),t("div",{staticClass:"responsive-table"},[t("table",[t("tr",[t("td",[e._v("Binary search\n   ")]),e._v(" "),t("td",[e._v("Sequential search\n   ")])]),e._v(" "),t("tr",[t("td",[t("ul",[t("li",[e._v("Requires a sorted algorithm\n")]),t("li",[e._v("More efficient for larger arrays\n")]),t("li",[e._v("Time complexity = O(log n)\n")])])]),e._v(" "),t("td",[t("ul",[t("li",[e._v("Simplest search strategy; does not require array to be sorted\n")]),t("li",[e._v("Relies on brute force strategy\n")]),t("li",[e._v("Time complexity = O(n)\n")])])])])])]),e._v(" "),t("h1",[e._v("Sorting")]),e._v(" "),t("h2",[e._v("Bubble sort")]),e._v(" "),t("pre",[t("code",{pre:!0},[e._v("LIST = [2, 3, 5, 1, 5, 10, 13, 8]\n\nloop K from 0 to LIST.length() - 1\n\tloop I from 0 to LIST.length() - 2\n\t//-2 because the last element has no value after\n\t\tif LIST[I] > LIST[I+1] then\t\t\n\t\t\tswap(LIST[I], LIST[I+1])\n")])]),e._v(" "),t("h2",[e._v("Selection sort")]),e._v(" "),t("pre",[t("code",{pre:!0},[e._v("LIST = [2, 3, 5, 1, 5, 10, 13, 8]\n\nloop I from 0 to LIST.length()-2  //once done till n-2, n-1 will be sorted already\n\tMIN = I\n\t\n\tloop J from I+1 to LIST.length()-1\n\t     if LIST[I] < LIST[MIN]\n\t\t\tMIN = J\n\n\tswap(LIST[I], LIST[MIN])\n")])]),e._v(" "),t("div",{staticClass:"responsive-table"},[t("table",[t("tr",[t("td",[e._v("Bubble sort\n   ")]),e._v(" "),t("td",[e._v("Selection sort\n   ")])]),e._v(" "),t("tr",[t("td",[t("ul",[t("li",[e._v("Repeatedly steps through an array then compared and swaps adjacent elements if they are not in correct order\n")]),t("li",[e._v("At the end of each pass, the highest number is bubbled up (end of array)\n")]),t("li",[e._v("Takes multiple passes until no swaps are necessary\n")]),t("li",[e._v("Slow and impractical\n")]),t("li",[e._v("Time complexity = O(n"),t("sup",[e._v("2")]),e._v(")\n")])])]),e._v(" "),t("td",[t("ul",[t("li",[e._v("Runs through the array and swaps the minimum value with the first value of the array\n")]),t("li",[e._v("Time complexity = O(n"),t("sup",[e._v("2")]),e._v(")\n")])])])])]),e._v(" "),t("tr",[t("td")])]),e._v(" "),t("h1",[e._v("Stacks")]),e._v(" "),t("ul",[t("li",[e._v("LIFO: last in, first out")]),e._v(" "),t("li",[e._v("Top pointer points to first element: "),t("code",{pre:!0},[e._v("PEEK() => STACK[TOP]")])]),e._v(" "),t("li",[e._v("Two methods:\n"),t("ul",[t("li",[t("code",{pre:!0},[e._v("PUSH()")])]),e._v(" "),t("li",[t("code",{pre:!0},[e._v("POP()")])])])])]),e._v(" "),t("h2",[e._v("Applications")]),e._v(" "),t("ul",[t("li",[e._v("Reversing a string")]),e._v(" "),t("li",[e._v("Convert an infix expression to postfix")])]),e._v(" "),t("h2",[e._v("Methods")]),e._v(" "),t("h3",[e._v("Push")]),e._v(" "),t("pre",[t("code",{pre:!0},[e._v('TOP = -1  // stack is empty\ninput item\n\nif (TOP == N-1) then\n  print "OVERFLOW"\nelse\n  top = TOP + 1\n  STACK[TOP] = item\nend if\n')])]),e._v(" "),t("p",[t("strong",[e._v("Overflow")]),e._v(" is when the stack is full and an element is being pushed.")]),e._v(" "),t("h3",[e._v("Pop")]),e._v(" "),t("pre",[t("code",{pre:!0},[e._v('TOP = 0  // no value for top as stack is empty\nif (TOP < 1) then\n  print "UNDERFLOW"\nelse\n  print STACK[TOP]\n  TOP = TOP -1\n  // return value and remove index\nend if\n')])]),e._v(" "),t("p",[t("strong",[e._v("Underflow")]),e._v(" is when the stack is empty but an element is being popped.")]),e._v(" "),t("h3",[e._v("Peek")]),e._v(" "),t("pre",[t("code",{pre:!0},[e._v("begin procedure PEEK\n  return stack[TOP]\nend procedure\n")])]),e._v(" "),t("h1",[e._v("Queue")]),e._v(" "),t("ul",[t("li",[e._v("FIFO: first in, first out\n"),t("ul",[t("li",[e._v("All "),t("strong",[e._v("insertions")]),e._v(" take place at the "),t("strong",[e._v("rear")]),e._v(", and all "),t("strong",[e._v("deletions")]),e._v(" take place at the "),t("strong",[e._v("front")])])])]),e._v(" "),t("li",[e._v("Two pointers:\n"),t("ul",[t("li",[t("code",{pre:!0},[e._v("FRONT")]),e._v(" returns the first value")]),e._v(" "),t("li",[t("code",{pre:!0},[e._v("REAR")]),e._v(" returns the last value")])])]),e._v(" "),t("li",[e._v("Top pointer points to first element: "),t("code",{pre:!0},[e._v("PEEK() => QUEUE[FRONT]")])]),e._v(" "),t("li",[e._v("Two methods:\n"),t("ul",[t("li",[t("code",{pre:!0},[e._v("ENQUEUE()")])]),e._v(" "),t("li",[t("code",{pre:!0},[e._v("DEQUE()")])])])]),e._v(" "),t("li",[e._v("When a value is dequeued, the value of "),t("code",{pre:!0},[e._v("FRONT()")]),e._v(" changes, and there is a "),t("em",[e._v("vacant")]),e._v(" space left (and the value is returned)")])]),e._v(" "),t("h2",[e._v("Methods")]),e._v(" "),t("h3",[e._v("Enqueue")]),e._v(" "),t("pre",[t("code",{pre:!0},[e._v('begin procedure ENQUEUE(DATA)\n  if QUEUE.isFull() then\n    return "OVERFLOW"\n    exit\n  end if\n  REAR = REAR + 1\n  QUEUE[REAR] = DATA\nend procedure\n')])]),e._v(" "),t("h3",[e._v("Dequeue")]),e._v(" "),t("pre",[t("code",{pre:!0},[e._v('begin procedure DEQUEUE\n  if QUEUE.isEmpty() then\n    return "UNDERFLOW"\n    exit\n  end if\n  DATA = QUEUE[FRONT]\n  FRONT = FRONT + 1  \n  // the front value is changed\n  // although the data still exists in the memory, it is not in the queue\n  return DATA\nend procedure\n')])]),e._v(" "),t("h3",[e._v("isFull")]),e._v(" "),t("pre",[t("code",{pre:!0},[e._v("begin procedure isFull\n  if (REAR == MAXSIZE) then  // max size is N - 1\n    return true\n  else\n    return false\n  end if\nend procedure\n")])]),e._v(" "),t("h3",[e._v("isEmpty")]),e._v(" "),t("pre",[t("code",{pre:!0},[e._v("begin procedure isEmpty\n  if (FONT < MINSIZE) OR (FRONT > REAR) then\n    return true\n  else\n    return false\n  end if\nend procedure\n")])]),e._v(" "),t("h3",[e._v("Peek")]),e._v(" "),t("pre",[t("code",{pre:!0},[e._v("begin procedure PEEK\n  return QUEUE[FRONT]\nend procedure\n")])])])}]}}}}}}]);