<!doctype html>
<html data-n-head-ssr data-n-head="">
  <head data-n-head="">
    <title data-n-head="true">important algorithms - computer-science</title><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-n-head="true" data-hid="description" name="description" content="My perfect Nuxt.js project"><meta data-n-head="true" name="theme-color" content="#ebebeb"><link data-n-head="true" rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="preload" href="/_nuxt/1e988892887ae859b600.js" as="script"><link rel="preload" href="/_nuxt/895579458ca7731cf8ea.js" as="script"><link rel="preload" href="/_nuxt/17e24a4181effd624233.js" as="script"><link rel="preload" href="/_nuxt/4f0ee4642ae49a7a05b4.js" as="script"><style data-vue-ssr-id="17cfdfa9:0 132df51d:0 44462401:0">.nuxt-progress{position:fixed;top:0;left:0;right:0;height:2px;width:0;opacity:1;transition:width .1s,opacity .4s;background-color:#fff;z-index:999999}.nuxt-progress.nuxt-progress-notransition{transition:none}.nuxt-progress-failed{background-color:red}*{margin:0;padding:0;box-sizing:border-box;font-family:-apple-system,system-ui,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif,BlinkMacSystemFont,Helvetica Neue,Arial;font-size:20px;font-size:var(--main-font-size);letter-spacing:1.1px}:root{--main-font-size:20px;--side-padding:30px;--main-padding:30px;--dense-padding:20px;--main-border:1px solid #ccc}@media screen and (max-width:500px){:root{--main-font-size:18px;--side-padding:24px;--main-padding:24px;--dense-padding:18px}}.container{padding:30px;padding:var(--main-padding)}.container.dense{padding:20px 30px;padding:var(--dense-padding) var(--main-padding)}.bottom-padding{padding-bottom:30px;padding-bottom:var(--main-padding)}.page-title{font-size:3rem;font-weight:900;text-transform:capitalize;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto;margin-bottom:30px;margin-bottom:var(--main-padding)}.page-subtitle{font-size:1.8rem;font-weight:300}.back,.back a{text-decoration:unset;color:unset;text-transform:capitalize}html{line-height:1.5}p{padding-bottom:1rem}h1,h2,h3,h4{padding-top:1rem;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto}h1{font-size:2.5rem}h1,h2{font-weight:700}h2{font-size:1.8rem}h3{font-size:1.3rem;font-weight:700}h4{font-size:1.1rem;font-weight:500}ol,ul{margin-left:2rem}table{border-collapse:collapse;margin-top:30px;margin-top:var(--main-padding);margin-bottom:30px;margin-bottom:var(--main-padding)}table,td,th{border:1px solid #000}td,th{padding:20px;padding:var(--dense-padding)}.responsive-table{width:100%;overflow-x:scroll}.wrapper{padding:30px 20%;padding:var(--main-padding) 20%}@media screen and (max-width:500px){.wrapper{padding:30px 5%;padding:var(--main-padding) 5%}}.content[data-v-479c0552],.page-title[data-v-479c0552]{border-bottom:var(--main-border)}.content[data-v-479c0552]{margin-bottom:var(--dense-padding)}</style>
  </head>
  <body data-n-head="">
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div><div class="wrapper"><div data-v-479c0552><a href="/computer-science" class="back active-link" data-v-479c0552>&lt; computer-science</a><div class="page-title" data-v-479c0552>Important algorithms</div><div class="content" data-v-479c0552><h1>Searching</h1>
<h2>Sequential search</h2>
<pre><code>LIST = [2, 3, 5, 1, 5, 10, 13, 8]
SEARCH = 2
FOUND = false

loop I from 0 to LIST.length()
	if LIST[I] == SEARCH then
		FOUND = true
		output SEARCH, "found at position", I
	end if
end loop

if FOUND == false then
	output "not found"
</code></pre>
<h2>Binary search</h2>
<pre><code>LIST = [1, 2, 4, 7, 10, 54, 55, 64, 345, 777, 787]
SEARCH = 2
START = 0
END = LIST.length()

while START &lt;= END
//this is the recursive function
	MID = (START + END) div 2
	if LIST[MID] == SEARCH
		output SEARCH, "found at position", MID
	else
		if SEARCH &lt; LIST[MID]
			END = MID - 1 //discarding middle element and everything after
		else
			START = MID + 1 //discarding middle element and everything before
</code></pre>
<div class="responsive-table">
<table>
  <tr>
   <td>Binary search
   </td>
   <td>Sequential search
   </td>
  </tr>
  <tr>
   <td>
<ul>
<li>Requires a sorted algorithm
</li><li>More efficient for larger arrays
</li><li>Time complexity = O(log n)
</li>
</ul>
   </td>
   <td>
<ul>
<li>Simplest search strategy; does not require array to be sorted
</li><li>Relies on brute force strategy
</li><li>Time complexity = O(n)
</li>
</ul>
   </td>
  </tr>
</table>
</div>
<h1>Sorting</h1>
<h2>Bubble sort</h2>
<pre><code>LIST = [2, 3, 5, 1, 5, 10, 13, 8]

loop K from 0 to LIST.length() - 1
	loop I from 0 to LIST.length() - 2
	//-2 because the last element has no value after
		if LIST[I] > LIST[I+1] then		
			swap(LIST[I], LIST[I+1])
</code></pre>
<h2>Selection sort</h2>
<pre><code>LIST = [2, 3, 5, 1, 5, 10, 13, 8]

loop I from 0 to LIST.length()-2  //once done till n-2, n-1 will be sorted already
	MIN = I
	
	loop J from I+1 to LIST.length()-1
	     if LIST[I] &lt; LIST[MIN]
			MIN = J

	swap(LIST[I], LIST[MIN])
</code></pre>
<div class="responsive-table">
<table>
  <tr>
   <td>Bubble sort
   </td>
   <td>Selection sort
   </td>
  </tr>
  <tr>
   <td>
<ul>
<li>Repeatedly steps through an array then compared and swaps adjacent elements if they are not in correct order
</li><li>At the end of each pass, the highest number is bubbled up (end of array)
</li><li>Takes multiple passes until no swaps are necessary
</li><li>Slow and impractical
</li><li>Time complexity = O(n<sup>2</sup>)
</li>
</ul>
   </td>
   <td>
<ul>
<li>Runs through the array and swaps the minimum value with the first value of the array
</li><li>Time complexity = O(n<sup>2</sup>)
</li>
</ul>
   </td>
  </tr>
</table>
   
  
  <tr>
   <td>
   </td>
  </tr>

</div>
<h1>Stacks</h1>
<ul>
<li>LIFO: last in, first out</li>
<li>Top pointer points to first element: <code>PEEK() => STACK[TOP]</code></li>
<li>Two methods:
<ul>
<li><code>PUSH()</code></li>
<li><code>POP()</code></li>
</ul>
</li>
</ul>
<h2>Applications</h2>
<ul>
<li>Reversing a string</li>
<li>Convert an infix expression to postfix</li>
</ul>
<h2>Methods</h2>
<h3>Push</h3>
<pre><code>TOP = -1  // stack is empty
input item

if (TOP == N-1) then
  print "OVERFLOW"
else
  top = TOP + 1
  STACK[TOP] = item
end if
</code></pre>
<p><strong>Overflow</strong> is when the stack is full and an element is being pushed.</p>
<h3>Pop</h3>
<pre><code>TOP = 0  // no value for top as stack is empty
if (TOP &lt; 1) then
  print "UNDERFLOW"
else
  print STACK[TOP]
  TOP = TOP -1
  // return value and remove index
end if
</code></pre>
<p><strong>Underflow</strong> is when the stack is empty but an element is being popped.</p>
<h3>Peek</h3>
<pre><code>begin procedure PEEK
  return stack[TOP]
end procedure
</code></pre>
<h1>Queue</h1>
<ul>
<li>FIFO: first in, first out
<ul>
<li>All <strong>insertions</strong> take place at the <strong>rear</strong>, and all <strong>deletions</strong> take place at the <strong>front</strong></li>
</ul>
</li>
<li>Two pointers:
<ul>
<li><code>FRONT</code> returns the first value</li>
<li><code>REAR</code> returns the last value</li>
</ul>
</li>
<li>Top pointer points to first element: <code>PEEK() => QUEUE[FRONT]</code></li>
<li>Two methods:
<ul>
<li><code>ENQUEUE()</code></li>
<li><code>DEQUE()</code></li>
</ul>
</li>
<li>When a value is dequeued, the value of <code>FRONT()</code> changes, and there is a <em>vacant</em> space left (and the value is returned)</li>
</ul>
<h2>Methods</h2>
<h3>Enqueue</h3>
<pre><code>begin procedure ENQUEUE(DATA)
  if QUEUE.isFull() then
    return "OVERFLOW"
    exit
  end if
  REAR = REAR + 1
  QUEUE[REAR] = DATA
end procedure
</code></pre>
<h3>Dequeue</h3>
<pre><code>begin procedure DEQUEUE
  if QUEUE.isEmpty() then
    return "UNDERFLOW"
    exit
  end if
  DATA = QUEUE[FRONT]
  FRONT = FRONT + 1  
  // the front value is changed
  // although the data still exists in the memory, it is not in the queue
  return DATA
end procedure
</code></pre>
<h3>isFull</h3>
<pre><code>begin procedure isFull
  if (REAR == MAXSIZE) then  // max size is N - 1
    return true
  else
    return false
  end if
end procedure
</code></pre>
<h3>isEmpty</h3>
<pre><code>begin procedure isEmpty
  if (FONT &lt; MINSIZE) OR (FRONT > REAR) then
    return true
  else
    return false
  end if
end procedure
</code></pre>
<h3>Peek</h3>
<pre><code>begin procedure PEEK
  return QUEUE[FRONT]
end procedure
</code></pre>
</div><a href="/computer-science" class="back active-link" data-v-479c0552>&lt; computer-science</a></div></div></div></div></div><script>window.__NUXT__={layout:"default",data:[{page:Object.create(null,{default:{writable:!0,enumerable:!0,value:{body:'# Searching\n\n\n## Sequential search\n\n\n```\nLIST = [2, 3, 5, 1, 5, 10, 13, 8]\nSEARCH = 2\nFOUND = false\n\nloop I from 0 to LIST.length()\n\tif LIST[I] == SEARCH then\n\t\tFOUND = true\n\t\toutput SEARCH, "found at position", I\n\tend if\nend loop\n\nif FOUND == false then\n\toutput "not found"\n```\n\n\n\n## Binary search\n\n```\nLIST = [1, 2, 4, 7, 10, 54, 55, 64, 345, 777, 787]\nSEARCH = 2\nSTART = 0\nEND = LIST.length()\n\nwhile START <= END\n//this is the recursive function\n\tMID = (START + END) div 2\n\tif LIST[MID] == SEARCH\n\t\toutput SEARCH, "found at position", MID\n\telse\n\t\tif SEARCH < LIST[MID]\n\t\t\tEND = MID - 1 //discarding middle element and everything after\n\t\telse\n\t\t\tSTART = MID + 1 //discarding middle element and everything before\n```\n\n\n\n<div class="responsive-table">\n<table>\n  <tr>\n   <td>Binary search\n   </td>\n   <td>Sequential search\n   </td>\n  </tr>\n  <tr>\n   <td>\n<ul>\n\n<li>Requires a sorted algorithm\n\n<li>More efficient for larger arrays\n\n<li>Time complexity = O(log n)\n</li>\n</ul>\n   </td>\n   <td>\n<ul>\n\n<li>Simplest search strategy; does not require array to be sorted\n\n<li>Relies on brute force strategy\n\n<li>Time complexity = O(n)\n</li>\n</ul>\n   </td>\n  </tr>\n</table>\n</div>\n\n\n# Sorting\n\n\n## Bubble sort\n\n```\nLIST = [2, 3, 5, 1, 5, 10, 13, 8]\n\nloop K from 0 to LIST.length() - 1\n\tloop I from 0 to LIST.length() - 2\n\t//-2 because the last element has no value after\n\t\tif LIST[I] > LIST[I+1] then\t\t\n\t\t\tswap(LIST[I], LIST[I+1])\n```\n\n\n\n## Selection sort\n\n```\nLIST = [2, 3, 5, 1, 5, 10, 13, 8]\n\nloop I from 0 to LIST.length()-2  //once done till n-2, n-1 will be sorted already\n\tMIN = I\n\t\n\tloop J from I+1 to LIST.length()-1\n\t     if LIST[I] < LIST[MIN]\n\t\t\tMIN = J\n\n\tswap(LIST[I], LIST[MIN])\n```\n\n\n\n\n\n<div class="responsive-table">\n<table>\n  <tr>\n   <td>Bubble sort\n   </td>\n   <td>Selection sort\n   </td>\n  </tr>\n  <tr>\n   <td>\n<ul>\n\n<li>Repeatedly steps through an array then compared and swaps adjacent elements if they are not in correct order\n\n<li>At the end of each pass, the highest number is bubbled up (end of array)\n\n<li>Takes multiple passes until no swaps are necessary\n\n<li>Slow and impractical\n\n<li>Time complexity = O(n<sup>2</sup>)\n</li>\n</ul>\n   </td>\n   <td>\n<ul>\n\n<li>Runs through the array and swaps the minimum value with the first value of the array\n\n<li>Time complexity = O(n<sup>2</sup>)\n</li>\n</ul>\n   </td>\n  </tr>\n</table>\n\n\n   </td>\n  </tr>\n  <tr>\n   <td>\n   </td>\n  </tr>\n</table>\n</div>\n\n\n\n\n# Stacks\n\n\n\n*   LIFO: last in, first out\n*   Top pointer points to first element: `PEEK() => STACK[TOP]`\n*   Two methods:\n    *   `PUSH()`\n    *   `POP()`\n\n\n## Applications\n\n\n\n*   Reversing a string\n*   Convert an infix expression to postfix\n\n\n## Methods\n\n\n### Push\n\n\n```\nTOP = -1  // stack is empty\ninput item\n\nif (TOP == N-1) then\n  print "OVERFLOW"\nelse\n  top = TOP + 1\n  STACK[TOP] = item\nend if\n```\n\n\n**Overflow** is when the stack is full and an element is being pushed.\n\n\n### Pop\n\n\n```\nTOP = 0  // no value for top as stack is empty\nif (TOP < 1) then\n  print "UNDERFLOW"\nelse\n  print STACK[TOP]\n  TOP = TOP -1\n  // return value and remove index\nend if\n```\n\n\n**Underflow** is when the stack is empty but an element is being popped.\n\n\n### Peek\n\n\n```\nbegin procedure PEEK\n  return stack[TOP]\nend procedure\n```\n\n\n\n# Queue\n\n\n\n*   FIFO: first in, first out\n    *   All **insertions** take place at the **rear**, and all **deletions** take place at the **front**\n*   Two pointers:\n    *   `FRONT` returns the first value\n    *   `REAR` returns the last value\n*   Top pointer points to first element: `PEEK() => QUEUE[FRONT]`\n*   Two methods:\n    *   `ENQUEUE()`\n    *   `DEQUE()`\n*   When a value is dequeued, the value of `FRONT()` changes, and there is a _vacant_ space left (and the value is returned)\n\n\n## Methods\n\n\n### Enqueue\n\n\n```\nbegin procedure ENQUEUE(DATA)\n  if QUEUE.isFull() then\n    return "OVERFLOW"\n    exit\n  end if\n  REAR = REAR + 1\n  QUEUE[REAR] = DATA\nend procedure\n```\n\n\n\n### Dequeue\n\n\n```\nbegin procedure DEQUEUE\n  if QUEUE.isEmpty() then\n    return "UNDERFLOW"\n    exit\n  end if\n  DATA = QUEUE[FRONT]\n  FRONT = FRONT + 1  \n  // the front value is changed\n  // although the data still exists in the memory, it is not in the queue\n  return DATA\nend procedure\n```\n\n\n\n### isFull\n\n\n```\nbegin procedure isFull\n  if (REAR == MAXSIZE) then  // max size is N - 1\n    return true\n  else\n    return false\n  end if\nend procedure\n```\n\n\n\n### isEmpty\n\n\n```\nbegin procedure isEmpty\n  if (FONT < MINSIZE) OR (FRONT > REAR) then\n    return true\n  else\n    return false\n  end if\nend procedure\n```\n\n\n\n### Peek\n\n\n```\nbegin procedure PEEK\n  return QUEUE[FRONT]\nend procedure\n```',html:'<h1>Searching</h1>\n<h2>Sequential search</h2>\n<pre><code>LIST = [2, 3, 5, 1, 5, 10, 13, 8]\nSEARCH = 2\nFOUND = false\n\nloop I from 0 to LIST.length()\n\tif LIST[I] == SEARCH then\n\t\tFOUND = true\n\t\toutput SEARCH, &quot;found at position&quot;, I\n\tend if\nend loop\n\nif FOUND == false then\n\toutput &quot;not found&quot;\n</code></pre>\n<h2>Binary search</h2>\n<pre><code>LIST = [1, 2, 4, 7, 10, 54, 55, 64, 345, 777, 787]\nSEARCH = 2\nSTART = 0\nEND = LIST.length()\n\nwhile START &lt;= END\n//this is the recursive function\n\tMID = (START + END) div 2\n\tif LIST[MID] == SEARCH\n\t\toutput SEARCH, &quot;found at position&quot;, MID\n\telse\n\t\tif SEARCH &lt; LIST[MID]\n\t\t\tEND = MID - 1 //discarding middle element and everything after\n\t\telse\n\t\t\tSTART = MID + 1 //discarding middle element and everything before\n</code></pre>\n<div class="responsive-table">\n<table>\n  <tr>\n   <td>Binary search\n   </td>\n   <td>Sequential search\n   </td>\n  </tr>\n  <tr>\n   <td>\n<ul>\n<li>Requires a sorted algorithm\n<li>More efficient for larger arrays\n<li>Time complexity = O(log n)\n</li>\n</ul>\n   </td>\n   <td>\n<ul>\n<li>Simplest search strategy; does not require array to be sorted\n<li>Relies on brute force strategy\n<li>Time complexity = O(n)\n</li>\n</ul>\n   </td>\n  </tr>\n</table>\n</div>\n<h1>Sorting</h1>\n<h2>Bubble sort</h2>\n<pre><code>LIST = [2, 3, 5, 1, 5, 10, 13, 8]\n\nloop K from 0 to LIST.length() - 1\n\tloop I from 0 to LIST.length() - 2\n\t//-2 because the last element has no value after\n\t\tif LIST[I] &gt; LIST[I+1] then\t\t\n\t\t\tswap(LIST[I], LIST[I+1])\n</code></pre>\n<h2>Selection sort</h2>\n<pre><code>LIST = [2, 3, 5, 1, 5, 10, 13, 8]\n\nloop I from 0 to LIST.length()-2  //once done till n-2, n-1 will be sorted already\n\tMIN = I\n\t\n\tloop J from I+1 to LIST.length()-1\n\t     if LIST[I] &lt; LIST[MIN]\n\t\t\tMIN = J\n\n\tswap(LIST[I], LIST[MIN])\n</code></pre>\n<div class="responsive-table">\n<table>\n  <tr>\n   <td>Bubble sort\n   </td>\n   <td>Selection sort\n   </td>\n  </tr>\n  <tr>\n   <td>\n<ul>\n<li>Repeatedly steps through an array then compared and swaps adjacent elements if they are not in correct order\n<li>At the end of each pass, the highest number is bubbled up (end of array)\n<li>Takes multiple passes until no swaps are necessary\n<li>Slow and impractical\n<li>Time complexity = O(n<sup>2</sup>)\n</li>\n</ul>\n   </td>\n   <td>\n<ul>\n<li>Runs through the array and swaps the minimum value with the first value of the array\n<li>Time complexity = O(n<sup>2</sup>)\n</li>\n</ul>\n   </td>\n  </tr>\n</table>\n   </td>\n  </tr>\n  <tr>\n   <td>\n   </td>\n  </tr>\n</table>\n</div>\n<h1>Stacks</h1>\n<ul>\n<li>LIFO: last in, first out</li>\n<li>Top pointer points to first element: <code>PEEK() =&gt; STACK[TOP]</code></li>\n<li>Two methods:\n<ul>\n<li><code>PUSH()</code></li>\n<li><code>POP()</code></li>\n</ul>\n</li>\n</ul>\n<h2>Applications</h2>\n<ul>\n<li>Reversing a string</li>\n<li>Convert an infix expression to postfix</li>\n</ul>\n<h2>Methods</h2>\n<h3>Push</h3>\n<pre><code>TOP = -1  // stack is empty\ninput item\n\nif (TOP == N-1) then\n  print &quot;OVERFLOW&quot;\nelse\n  top = TOP + 1\n  STACK[TOP] = item\nend if\n</code></pre>\n<p><strong>Overflow</strong> is when the stack is full and an element is being pushed.</p>\n<h3>Pop</h3>\n<pre><code>TOP = 0  // no value for top as stack is empty\nif (TOP &lt; 1) then\n  print &quot;UNDERFLOW&quot;\nelse\n  print STACK[TOP]\n  TOP = TOP -1\n  // return value and remove index\nend if\n</code></pre>\n<p><strong>Underflow</strong> is when the stack is empty but an element is being popped.</p>\n<h3>Peek</h3>\n<pre><code>begin procedure PEEK\n  return stack[TOP]\nend procedure\n</code></pre>\n<h1>Queue</h1>\n<ul>\n<li>FIFO: first in, first out\n<ul>\n<li>All <strong>insertions</strong> take place at the <strong>rear</strong>, and all <strong>deletions</strong> take place at the <strong>front</strong></li>\n</ul>\n</li>\n<li>Two pointers:\n<ul>\n<li><code>FRONT</code> returns the first value</li>\n<li><code>REAR</code> returns the last value</li>\n</ul>\n</li>\n<li>Top pointer points to first element: <code>PEEK() =&gt; QUEUE[FRONT]</code></li>\n<li>Two methods:\n<ul>\n<li><code>ENQUEUE()</code></li>\n<li><code>DEQUE()</code></li>\n</ul>\n</li>\n<li>When a value is dequeued, the value of <code>FRONT()</code> changes, and there is a <em>vacant</em> space left (and the value is returned)</li>\n</ul>\n<h2>Methods</h2>\n<h3>Enqueue</h3>\n<pre><code>begin procedure ENQUEUE(DATA)\n  if QUEUE.isFull() then\n    return &quot;OVERFLOW&quot;\n    exit\n  end if\n  REAR = REAR + 1\n  QUEUE[REAR] = DATA\nend procedure\n</code></pre>\n<h3>Dequeue</h3>\n<pre><code>begin procedure DEQUEUE\n  if QUEUE.isEmpty() then\n    return &quot;UNDERFLOW&quot;\n    exit\n  end if\n  DATA = QUEUE[FRONT]\n  FRONT = FRONT + 1  \n  // the front value is changed\n  // although the data still exists in the memory, it is not in the queue\n  return DATA\nend procedure\n</code></pre>\n<h3>isFull</h3>\n<pre><code>begin procedure isFull\n  if (REAR == MAXSIZE) then  // max size is N - 1\n    return true\n  else\n    return false\n  end if\nend procedure\n</code></pre>\n<h3>isEmpty</h3>\n<pre><code>begin procedure isEmpty\n  if (FONT &lt; MINSIZE) OR (FRONT &gt; REAR) then\n    return true\n  else\n    return false\n  end if\nend procedure\n</code></pre>\n<h3>Peek</h3>\n<pre><code>begin procedure PEEK\n  return QUEUE[FRONT]\nend procedure\n</code></pre>\n',attributes:{title:"Important algorithms",link:"important-algorithms",_meta:{resourcePath:"/Users/parthkabra/Documents/Code/Web/Nuxt/ib-notes/contents/pages/computer-science/important-algorithms.md"}},vue:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:'return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"dynamicMarkdown"},[_c(\'h1\',[_vm._v("Searching")]),_vm._v(" "),_c(\'h2\',[_vm._v("Sequential search")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("LIST = [2, 3, 5, 1, 5, 10, 13, 8]\\nSEARCH = 2\\nFOUND = false\\n\\nloop I from 0 to LIST.length()\\n\\tif LIST[I] == SEARCH then\\n\\t\\tFOUND = true\\n\\t\\toutput SEARCH, \\"found at position\\", I\\n\\tend if\\nend loop\\n\\nif FOUND == false then\\n\\toutput \\"not found\\"\\n")])]),_vm._v(" "),_c(\'h2\',[_vm._v("Binary search")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("LIST = [1, 2, 4, 7, 10, 54, 55, 64, 345, 777, 787]\\nSEARCH = 2\\nSTART = 0\\nEND = LIST.length()\\n\\nwhile START <= END\\n//this is the recursive function\\n\\tMID = (START + END) div 2\\n\\tif LIST[MID] == SEARCH\\n\\t\\toutput SEARCH, \\"found at position\\", MID\\n\\telse\\n\\t\\tif SEARCH < LIST[MID]\\n\\t\\t\\tEND = MID - 1 //discarding middle element and everything after\\n\\t\\telse\\n\\t\\t\\tSTART = MID + 1 //discarding middle element and everything before\\n")])]),_vm._v(" "),_c(\'div\',{staticClass:"responsive-table"},[_c(\'table\',[_c(\'tr\',[_c(\'td\',[_vm._v("Binary search\\n   ")]),_vm._v(" "),_c(\'td\',[_vm._v("Sequential search\\n   ")])]),_vm._v(" "),_c(\'tr\',[_c(\'td\',[_c(\'ul\',[_c(\'li\',[_vm._v("Requires a sorted algorithm\\n")]),_c(\'li\',[_vm._v("More efficient for larger arrays\\n")]),_c(\'li\',[_vm._v("Time complexity = O(log n)\\n")])])]),_vm._v(" "),_c(\'td\',[_c(\'ul\',[_c(\'li\',[_vm._v("Simplest search strategy; does not require array to be sorted\\n")]),_c(\'li\',[_vm._v("Relies on brute force strategy\\n")]),_c(\'li\',[_vm._v("Time complexity = O(n)\\n")])])])])])]),_vm._v(" "),_c(\'h1\',[_vm._v("Sorting")]),_vm._v(" "),_c(\'h2\',[_vm._v("Bubble sort")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("LIST = [2, 3, 5, 1, 5, 10, 13, 8]\\n\\nloop K from 0 to LIST.length() - 1\\n\\tloop I from 0 to LIST.length() - 2\\n\\t//-2 because the last element has no value after\\n\\t\\tif LIST[I] > LIST[I+1] then\\t\\t\\n\\t\\t\\tswap(LIST[I], LIST[I+1])\\n")])]),_vm._v(" "),_c(\'h2\',[_vm._v("Selection sort")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("LIST = [2, 3, 5, 1, 5, 10, 13, 8]\\n\\nloop I from 0 to LIST.length()-2  //once done till n-2, n-1 will be sorted already\\n\\tMIN = I\\n\\t\\n\\tloop J from I+1 to LIST.length()-1\\n\\t     if LIST[I] < LIST[MIN]\\n\\t\\t\\tMIN = J\\n\\n\\tswap(LIST[I], LIST[MIN])\\n")])]),_vm._v(" "),_c(\'div\',{staticClass:"responsive-table"},[_c(\'table\',[_c(\'tr\',[_c(\'td\',[_vm._v("Bubble sort\\n   ")]),_vm._v(" "),_c(\'td\',[_vm._v("Selection sort\\n   ")])]),_vm._v(" "),_c(\'tr\',[_c(\'td\',[_c(\'ul\',[_c(\'li\',[_vm._v("Repeatedly steps through an array then compared and swaps adjacent elements if they are not in correct order\\n")]),_c(\'li\',[_vm._v("At the end of each pass, the highest number is bubbled up (end of array)\\n")]),_c(\'li\',[_vm._v("Takes multiple passes until no swaps are necessary\\n")]),_c(\'li\',[_vm._v("Slow and impractical\\n")]),_c(\'li\',[_vm._v("Time complexity = O(n"),_c(\'sup\',[_vm._v("2")]),_vm._v(")\\n")])])]),_vm._v(" "),_c(\'td\',[_c(\'ul\',[_c(\'li\',[_vm._v("Runs through the array and swaps the minimum value with the first value of the array\\n")]),_c(\'li\',[_vm._v("Time complexity = O(n"),_c(\'sup\',[_vm._v("2")]),_vm._v(")\\n")])])])])]),_vm._v(" "),_c(\'tr\',[_c(\'td\')])]),_vm._v(" "),_c(\'h1\',[_vm._v("Stacks")]),_vm._v(" "),_c(\'ul\',[_c(\'li\',[_vm._v("LIFO: last in, first out")]),_vm._v(" "),_c(\'li\',[_vm._v("Top pointer points to first element: "),_c(\'code\',{pre:true},[_vm._v("PEEK() => STACK[TOP]")])]),_vm._v(" "),_c(\'li\',[_vm._v("Two methods:\\n"),_c(\'ul\',[_c(\'li\',[_c(\'code\',{pre:true},[_vm._v("PUSH()")])]),_vm._v(" "),_c(\'li\',[_c(\'code\',{pre:true},[_vm._v("POP()")])])])])]),_vm._v(" "),_c(\'h2\',[_vm._v("Applications")]),_vm._v(" "),_c(\'ul\',[_c(\'li\',[_vm._v("Reversing a string")]),_vm._v(" "),_c(\'li\',[_vm._v("Convert an infix expression to postfix")])]),_vm._v(" "),_c(\'h2\',[_vm._v("Methods")]),_vm._v(" "),_c(\'h3\',[_vm._v("Push")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("TOP = -1  // stack is empty\\ninput item\\n\\nif (TOP == N-1) then\\n  print \\"OVERFLOW\\"\\nelse\\n  top = TOP + 1\\n  STACK[TOP] = item\\nend if\\n")])]),_vm._v(" "),_c(\'p\',[_c(\'strong\',[_vm._v("Overflow")]),_vm._v(" is when the stack is full and an element is being pushed.")]),_vm._v(" "),_c(\'h3\',[_vm._v("Pop")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("TOP = 0  // no value for top as stack is empty\\nif (TOP < 1) then\\n  print \\"UNDERFLOW\\"\\nelse\\n  print STACK[TOP]\\n  TOP = TOP -1\\n  // return value and remove index\\nend if\\n")])]),_vm._v(" "),_c(\'p\',[_c(\'strong\',[_vm._v("Underflow")]),_vm._v(" is when the stack is empty but an element is being popped.")]),_vm._v(" "),_c(\'h3\',[_vm._v("Peek")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("begin procedure PEEK\\n  return stack[TOP]\\nend procedure\\n")])]),_vm._v(" "),_c(\'h1\',[_vm._v("Queue")]),_vm._v(" "),_c(\'ul\',[_c(\'li\',[_vm._v("FIFO: first in, first out\\n"),_c(\'ul\',[_c(\'li\',[_vm._v("All "),_c(\'strong\',[_vm._v("insertions")]),_vm._v(" take place at the "),_c(\'strong\',[_vm._v("rear")]),_vm._v(", and all "),_c(\'strong\',[_vm._v("deletions")]),_vm._v(" take place at the "),_c(\'strong\',[_vm._v("front")])])])]),_vm._v(" "),_c(\'li\',[_vm._v("Two pointers:\\n"),_c(\'ul\',[_c(\'li\',[_c(\'code\',{pre:true},[_vm._v("FRONT")]),_vm._v(" returns the first value")]),_vm._v(" "),_c(\'li\',[_c(\'code\',{pre:true},[_vm._v("REAR")]),_vm._v(" returns the last value")])])]),_vm._v(" "),_c(\'li\',[_vm._v("Top pointer points to first element: "),_c(\'code\',{pre:true},[_vm._v("PEEK() => QUEUE[FRONT]")])]),_vm._v(" "),_c(\'li\',[_vm._v("Two methods:\\n"),_c(\'ul\',[_c(\'li\',[_c(\'code\',{pre:true},[_vm._v("ENQUEUE()")])]),_vm._v(" "),_c(\'li\',[_c(\'code\',{pre:true},[_vm._v("DEQUE()")])])])]),_vm._v(" "),_c(\'li\',[_vm._v("When a value is dequeued, the value of "),_c(\'code\',{pre:true},[_vm._v("FRONT()")]),_vm._v(" changes, and there is a "),_c(\'em\',[_vm._v("vacant")]),_vm._v(" space left (and the value is returned)")])]),_vm._v(" "),_c(\'h2\',[_vm._v("Methods")]),_vm._v(" "),_c(\'h3\',[_vm._v("Enqueue")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("begin procedure ENQUEUE(DATA)\\n  if QUEUE.isFull() then\\n    return \\"OVERFLOW\\"\\n    exit\\n  end if\\n  REAR = REAR + 1\\n  QUEUE[REAR] = DATA\\nend procedure\\n")])]),_vm._v(" "),_c(\'h3\',[_vm._v("Dequeue")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("begin procedure DEQUEUE\\n  if QUEUE.isEmpty() then\\n    return \\"UNDERFLOW\\"\\n    exit\\n  end if\\n  DATA = QUEUE[FRONT]\\n  FRONT = FRONT + 1  \\n  // the front value is changed\\n  // although the data still exists in the memory, it is not in the queue\\n  return DATA\\nend procedure\\n")])]),_vm._v(" "),_c(\'h3\',[_vm._v("isFull")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("begin procedure isFull\\n  if (REAR == MAXSIZE) then  // max size is N - 1\\n    return true\\n  else\\n    return false\\n  end if\\nend procedure\\n")])]),_vm._v(" "),_c(\'h3\',[_vm._v("isEmpty")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("begin procedure isEmpty\\n  if (FONT < MINSIZE) OR (FRONT > REAR) then\\n    return true\\n  else\\n    return false\\n  end if\\nend procedure\\n")])]),_vm._v(" "),_c(\'h3\',[_vm._v("Peek")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("begin procedure PEEK\\n  return QUEUE[FRONT]\\nend procedure\\n")])])]) }]',component:{data:{},render:{},created:{}}}}},body:{writable:!0,enumerable:!0,value:'# Searching\n\n\n## Sequential search\n\n\n```\nLIST = [2, 3, 5, 1, 5, 10, 13, 8]\nSEARCH = 2\nFOUND = false\n\nloop I from 0 to LIST.length()\n\tif LIST[I] == SEARCH then\n\t\tFOUND = true\n\t\toutput SEARCH, "found at position", I\n\tend if\nend loop\n\nif FOUND == false then\n\toutput "not found"\n```\n\n\n\n## Binary search\n\n```\nLIST = [1, 2, 4, 7, 10, 54, 55, 64, 345, 777, 787]\nSEARCH = 2\nSTART = 0\nEND = LIST.length()\n\nwhile START <= END\n//this is the recursive function\n\tMID = (START + END) div 2\n\tif LIST[MID] == SEARCH\n\t\toutput SEARCH, "found at position", MID\n\telse\n\t\tif SEARCH < LIST[MID]\n\t\t\tEND = MID - 1 //discarding middle element and everything after\n\t\telse\n\t\t\tSTART = MID + 1 //discarding middle element and everything before\n```\n\n\n\n<div class="responsive-table">\n<table>\n  <tr>\n   <td>Binary search\n   </td>\n   <td>Sequential search\n   </td>\n  </tr>\n  <tr>\n   <td>\n<ul>\n\n<li>Requires a sorted algorithm\n\n<li>More efficient for larger arrays\n\n<li>Time complexity = O(log n)\n</li>\n</ul>\n   </td>\n   <td>\n<ul>\n\n<li>Simplest search strategy; does not require array to be sorted\n\n<li>Relies on brute force strategy\n\n<li>Time complexity = O(n)\n</li>\n</ul>\n   </td>\n  </tr>\n</table>\n</div>\n\n\n# Sorting\n\n\n## Bubble sort\n\n```\nLIST = [2, 3, 5, 1, 5, 10, 13, 8]\n\nloop K from 0 to LIST.length() - 1\n\tloop I from 0 to LIST.length() - 2\n\t//-2 because the last element has no value after\n\t\tif LIST[I] > LIST[I+1] then\t\t\n\t\t\tswap(LIST[I], LIST[I+1])\n```\n\n\n\n## Selection sort\n\n```\nLIST = [2, 3, 5, 1, 5, 10, 13, 8]\n\nloop I from 0 to LIST.length()-2  //once done till n-2, n-1 will be sorted already\n\tMIN = I\n\t\n\tloop J from I+1 to LIST.length()-1\n\t     if LIST[I] < LIST[MIN]\n\t\t\tMIN = J\n\n\tswap(LIST[I], LIST[MIN])\n```\n\n\n\n\n\n<div class="responsive-table">\n<table>\n  <tr>\n   <td>Bubble sort\n   </td>\n   <td>Selection sort\n   </td>\n  </tr>\n  <tr>\n   <td>\n<ul>\n\n<li>Repeatedly steps through an array then compared and swaps adjacent elements if they are not in correct order\n\n<li>At the end of each pass, the highest number is bubbled up (end of array)\n\n<li>Takes multiple passes until no swaps are necessary\n\n<li>Slow and impractical\n\n<li>Time complexity = O(n<sup>2</sup>)\n</li>\n</ul>\n   </td>\n   <td>\n<ul>\n\n<li>Runs through the array and swaps the minimum value with the first value of the array\n\n<li>Time complexity = O(n<sup>2</sup>)\n</li>\n</ul>\n   </td>\n  </tr>\n</table>\n\n\n   </td>\n  </tr>\n  <tr>\n   <td>\n   </td>\n  </tr>\n</table>\n</div>\n\n\n\n\n# Stacks\n\n\n\n*   LIFO: last in, first out\n*   Top pointer points to first element: `PEEK() => STACK[TOP]`\n*   Two methods:\n    *   `PUSH()`\n    *   `POP()`\n\n\n## Applications\n\n\n\n*   Reversing a string\n*   Convert an infix expression to postfix\n\n\n## Methods\n\n\n### Push\n\n\n```\nTOP = -1  // stack is empty\ninput item\n\nif (TOP == N-1) then\n  print "OVERFLOW"\nelse\n  top = TOP + 1\n  STACK[TOP] = item\nend if\n```\n\n\n**Overflow** is when the stack is full and an element is being pushed.\n\n\n### Pop\n\n\n```\nTOP = 0  // no value for top as stack is empty\nif (TOP < 1) then\n  print "UNDERFLOW"\nelse\n  print STACK[TOP]\n  TOP = TOP -1\n  // return value and remove index\nend if\n```\n\n\n**Underflow** is when the stack is empty but an element is being popped.\n\n\n### Peek\n\n\n```\nbegin procedure PEEK\n  return stack[TOP]\nend procedure\n```\n\n\n\n# Queue\n\n\n\n*   FIFO: first in, first out\n    *   All **insertions** take place at the **rear**, and all **deletions** take place at the **front**\n*   Two pointers:\n    *   `FRONT` returns the first value\n    *   `REAR` returns the last value\n*   Top pointer points to first element: `PEEK() => QUEUE[FRONT]`\n*   Two methods:\n    *   `ENQUEUE()`\n    *   `DEQUE()`\n*   When a value is dequeued, the value of `FRONT()` changes, and there is a _vacant_ space left (and the value is returned)\n\n\n## Methods\n\n\n### Enqueue\n\n\n```\nbegin procedure ENQUEUE(DATA)\n  if QUEUE.isFull() then\n    return "OVERFLOW"\n    exit\n  end if\n  REAR = REAR + 1\n  QUEUE[REAR] = DATA\nend procedure\n```\n\n\n\n### Dequeue\n\n\n```\nbegin procedure DEQUEUE\n  if QUEUE.isEmpty() then\n    return "UNDERFLOW"\n    exit\n  end if\n  DATA = QUEUE[FRONT]\n  FRONT = FRONT + 1  \n  // the front value is changed\n  // although the data still exists in the memory, it is not in the queue\n  return DATA\nend procedure\n```\n\n\n\n### isFull\n\n\n```\nbegin procedure isFull\n  if (REAR == MAXSIZE) then  // max size is N - 1\n    return true\n  else\n    return false\n  end if\nend procedure\n```\n\n\n\n### isEmpty\n\n\n```\nbegin procedure isEmpty\n  if (FONT < MINSIZE) OR (FRONT > REAR) then\n    return true\n  else\n    return false\n  end if\nend procedure\n```\n\n\n\n### Peek\n\n\n```\nbegin procedure PEEK\n  return QUEUE[FRONT]\nend procedure\n```'},html:{writable:!0,enumerable:!0,value:'<h1>Searching</h1>\n<h2>Sequential search</h2>\n<pre><code>LIST = [2, 3, 5, 1, 5, 10, 13, 8]\nSEARCH = 2\nFOUND = false\n\nloop I from 0 to LIST.length()\n\tif LIST[I] == SEARCH then\n\t\tFOUND = true\n\t\toutput SEARCH, &quot;found at position&quot;, I\n\tend if\nend loop\n\nif FOUND == false then\n\toutput &quot;not found&quot;\n</code></pre>\n<h2>Binary search</h2>\n<pre><code>LIST = [1, 2, 4, 7, 10, 54, 55, 64, 345, 777, 787]\nSEARCH = 2\nSTART = 0\nEND = LIST.length()\n\nwhile START &lt;= END\n//this is the recursive function\n\tMID = (START + END) div 2\n\tif LIST[MID] == SEARCH\n\t\toutput SEARCH, &quot;found at position&quot;, MID\n\telse\n\t\tif SEARCH &lt; LIST[MID]\n\t\t\tEND = MID - 1 //discarding middle element and everything after\n\t\telse\n\t\t\tSTART = MID + 1 //discarding middle element and everything before\n</code></pre>\n<div class="responsive-table">\n<table>\n  <tr>\n   <td>Binary search\n   </td>\n   <td>Sequential search\n   </td>\n  </tr>\n  <tr>\n   <td>\n<ul>\n<li>Requires a sorted algorithm\n<li>More efficient for larger arrays\n<li>Time complexity = O(log n)\n</li>\n</ul>\n   </td>\n   <td>\n<ul>\n<li>Simplest search strategy; does not require array to be sorted\n<li>Relies on brute force strategy\n<li>Time complexity = O(n)\n</li>\n</ul>\n   </td>\n  </tr>\n</table>\n</div>\n<h1>Sorting</h1>\n<h2>Bubble sort</h2>\n<pre><code>LIST = [2, 3, 5, 1, 5, 10, 13, 8]\n\nloop K from 0 to LIST.length() - 1\n\tloop I from 0 to LIST.length() - 2\n\t//-2 because the last element has no value after\n\t\tif LIST[I] &gt; LIST[I+1] then\t\t\n\t\t\tswap(LIST[I], LIST[I+1])\n</code></pre>\n<h2>Selection sort</h2>\n<pre><code>LIST = [2, 3, 5, 1, 5, 10, 13, 8]\n\nloop I from 0 to LIST.length()-2  //once done till n-2, n-1 will be sorted already\n\tMIN = I\n\t\n\tloop J from I+1 to LIST.length()-1\n\t     if LIST[I] &lt; LIST[MIN]\n\t\t\tMIN = J\n\n\tswap(LIST[I], LIST[MIN])\n</code></pre>\n<div class="responsive-table">\n<table>\n  <tr>\n   <td>Bubble sort\n   </td>\n   <td>Selection sort\n   </td>\n  </tr>\n  <tr>\n   <td>\n<ul>\n<li>Repeatedly steps through an array then compared and swaps adjacent elements if they are not in correct order\n<li>At the end of each pass, the highest number is bubbled up (end of array)\n<li>Takes multiple passes until no swaps are necessary\n<li>Slow and impractical\n<li>Time complexity = O(n<sup>2</sup>)\n</li>\n</ul>\n   </td>\n   <td>\n<ul>\n<li>Runs through the array and swaps the minimum value with the first value of the array\n<li>Time complexity = O(n<sup>2</sup>)\n</li>\n</ul>\n   </td>\n  </tr>\n</table>\n   </td>\n  </tr>\n  <tr>\n   <td>\n   </td>\n  </tr>\n</table>\n</div>\n<h1>Stacks</h1>\n<ul>\n<li>LIFO: last in, first out</li>\n<li>Top pointer points to first element: <code>PEEK() =&gt; STACK[TOP]</code></li>\n<li>Two methods:\n<ul>\n<li><code>PUSH()</code></li>\n<li><code>POP()</code></li>\n</ul>\n</li>\n</ul>\n<h2>Applications</h2>\n<ul>\n<li>Reversing a string</li>\n<li>Convert an infix expression to postfix</li>\n</ul>\n<h2>Methods</h2>\n<h3>Push</h3>\n<pre><code>TOP = -1  // stack is empty\ninput item\n\nif (TOP == N-1) then\n  print &quot;OVERFLOW&quot;\nelse\n  top = TOP + 1\n  STACK[TOP] = item\nend if\n</code></pre>\n<p><strong>Overflow</strong> is when the stack is full and an element is being pushed.</p>\n<h3>Pop</h3>\n<pre><code>TOP = 0  // no value for top as stack is empty\nif (TOP &lt; 1) then\n  print &quot;UNDERFLOW&quot;\nelse\n  print STACK[TOP]\n  TOP = TOP -1\n  // return value and remove index\nend if\n</code></pre>\n<p><strong>Underflow</strong> is when the stack is empty but an element is being popped.</p>\n<h3>Peek</h3>\n<pre><code>begin procedure PEEK\n  return stack[TOP]\nend procedure\n</code></pre>\n<h1>Queue</h1>\n<ul>\n<li>FIFO: first in, first out\n<ul>\n<li>All <strong>insertions</strong> take place at the <strong>rear</strong>, and all <strong>deletions</strong> take place at the <strong>front</strong></li>\n</ul>\n</li>\n<li>Two pointers:\n<ul>\n<li><code>FRONT</code> returns the first value</li>\n<li><code>REAR</code> returns the last value</li>\n</ul>\n</li>\n<li>Top pointer points to first element: <code>PEEK() =&gt; QUEUE[FRONT]</code></li>\n<li>Two methods:\n<ul>\n<li><code>ENQUEUE()</code></li>\n<li><code>DEQUE()</code></li>\n</ul>\n</li>\n<li>When a value is dequeued, the value of <code>FRONT()</code> changes, and there is a <em>vacant</em> space left (and the value is returned)</li>\n</ul>\n<h2>Methods</h2>\n<h3>Enqueue</h3>\n<pre><code>begin procedure ENQUEUE(DATA)\n  if QUEUE.isFull() then\n    return &quot;OVERFLOW&quot;\n    exit\n  end if\n  REAR = REAR + 1\n  QUEUE[REAR] = DATA\nend procedure\n</code></pre>\n<h3>Dequeue</h3>\n<pre><code>begin procedure DEQUEUE\n  if QUEUE.isEmpty() then\n    return &quot;UNDERFLOW&quot;\n    exit\n  end if\n  DATA = QUEUE[FRONT]\n  FRONT = FRONT + 1  \n  // the front value is changed\n  // although the data still exists in the memory, it is not in the queue\n  return DATA\nend procedure\n</code></pre>\n<h3>isFull</h3>\n<pre><code>begin procedure isFull\n  if (REAR == MAXSIZE) then  // max size is N - 1\n    return true\n  else\n    return false\n  end if\nend procedure\n</code></pre>\n<h3>isEmpty</h3>\n<pre><code>begin procedure isEmpty\n  if (FONT &lt; MINSIZE) OR (FRONT &gt; REAR) then\n    return true\n  else\n    return false\n  end if\nend procedure\n</code></pre>\n<h3>Peek</h3>\n<pre><code>begin procedure PEEK\n  return QUEUE[FRONT]\nend procedure\n</code></pre>\n'},attributes:{writable:!0,enumerable:!0,value:{title:"Important algorithms",link:"important-algorithms",_meta:{resourcePath:"/Users/parthkabra/Documents/Code/Web/Nuxt/ib-notes/contents/pages/computer-science/important-algorithms.md"}}},vue:{writable:!0,enumerable:!0,value:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:'return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"dynamicMarkdown"},[_c(\'h1\',[_vm._v("Searching")]),_vm._v(" "),_c(\'h2\',[_vm._v("Sequential search")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("LIST = [2, 3, 5, 1, 5, 10, 13, 8]\\nSEARCH = 2\\nFOUND = false\\n\\nloop I from 0 to LIST.length()\\n\\tif LIST[I] == SEARCH then\\n\\t\\tFOUND = true\\n\\t\\toutput SEARCH, \\"found at position\\", I\\n\\tend if\\nend loop\\n\\nif FOUND == false then\\n\\toutput \\"not found\\"\\n")])]),_vm._v(" "),_c(\'h2\',[_vm._v("Binary search")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("LIST = [1, 2, 4, 7, 10, 54, 55, 64, 345, 777, 787]\\nSEARCH = 2\\nSTART = 0\\nEND = LIST.length()\\n\\nwhile START <= END\\n//this is the recursive function\\n\\tMID = (START + END) div 2\\n\\tif LIST[MID] == SEARCH\\n\\t\\toutput SEARCH, \\"found at position\\", MID\\n\\telse\\n\\t\\tif SEARCH < LIST[MID]\\n\\t\\t\\tEND = MID - 1 //discarding middle element and everything after\\n\\t\\telse\\n\\t\\t\\tSTART = MID + 1 //discarding middle element and everything before\\n")])]),_vm._v(" "),_c(\'div\',{staticClass:"responsive-table"},[_c(\'table\',[_c(\'tr\',[_c(\'td\',[_vm._v("Binary search\\n   ")]),_vm._v(" "),_c(\'td\',[_vm._v("Sequential search\\n   ")])]),_vm._v(" "),_c(\'tr\',[_c(\'td\',[_c(\'ul\',[_c(\'li\',[_vm._v("Requires a sorted algorithm\\n")]),_c(\'li\',[_vm._v("More efficient for larger arrays\\n")]),_c(\'li\',[_vm._v("Time complexity = O(log n)\\n")])])]),_vm._v(" "),_c(\'td\',[_c(\'ul\',[_c(\'li\',[_vm._v("Simplest search strategy; does not require array to be sorted\\n")]),_c(\'li\',[_vm._v("Relies on brute force strategy\\n")]),_c(\'li\',[_vm._v("Time complexity = O(n)\\n")])])])])])]),_vm._v(" "),_c(\'h1\',[_vm._v("Sorting")]),_vm._v(" "),_c(\'h2\',[_vm._v("Bubble sort")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("LIST = [2, 3, 5, 1, 5, 10, 13, 8]\\n\\nloop K from 0 to LIST.length() - 1\\n\\tloop I from 0 to LIST.length() - 2\\n\\t//-2 because the last element has no value after\\n\\t\\tif LIST[I] > LIST[I+1] then\\t\\t\\n\\t\\t\\tswap(LIST[I], LIST[I+1])\\n")])]),_vm._v(" "),_c(\'h2\',[_vm._v("Selection sort")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("LIST = [2, 3, 5, 1, 5, 10, 13, 8]\\n\\nloop I from 0 to LIST.length()-2  //once done till n-2, n-1 will be sorted already\\n\\tMIN = I\\n\\t\\n\\tloop J from I+1 to LIST.length()-1\\n\\t     if LIST[I] < LIST[MIN]\\n\\t\\t\\tMIN = J\\n\\n\\tswap(LIST[I], LIST[MIN])\\n")])]),_vm._v(" "),_c(\'div\',{staticClass:"responsive-table"},[_c(\'table\',[_c(\'tr\',[_c(\'td\',[_vm._v("Bubble sort\\n   ")]),_vm._v(" "),_c(\'td\',[_vm._v("Selection sort\\n   ")])]),_vm._v(" "),_c(\'tr\',[_c(\'td\',[_c(\'ul\',[_c(\'li\',[_vm._v("Repeatedly steps through an array then compared and swaps adjacent elements if they are not in correct order\\n")]),_c(\'li\',[_vm._v("At the end of each pass, the highest number is bubbled up (end of array)\\n")]),_c(\'li\',[_vm._v("Takes multiple passes until no swaps are necessary\\n")]),_c(\'li\',[_vm._v("Slow and impractical\\n")]),_c(\'li\',[_vm._v("Time complexity = O(n"),_c(\'sup\',[_vm._v("2")]),_vm._v(")\\n")])])]),_vm._v(" "),_c(\'td\',[_c(\'ul\',[_c(\'li\',[_vm._v("Runs through the array and swaps the minimum value with the first value of the array\\n")]),_c(\'li\',[_vm._v("Time complexity = O(n"),_c(\'sup\',[_vm._v("2")]),_vm._v(")\\n")])])])])]),_vm._v(" "),_c(\'tr\',[_c(\'td\')])]),_vm._v(" "),_c(\'h1\',[_vm._v("Stacks")]),_vm._v(" "),_c(\'ul\',[_c(\'li\',[_vm._v("LIFO: last in, first out")]),_vm._v(" "),_c(\'li\',[_vm._v("Top pointer points to first element: "),_c(\'code\',{pre:true},[_vm._v("PEEK() => STACK[TOP]")])]),_vm._v(" "),_c(\'li\',[_vm._v("Two methods:\\n"),_c(\'ul\',[_c(\'li\',[_c(\'code\',{pre:true},[_vm._v("PUSH()")])]),_vm._v(" "),_c(\'li\',[_c(\'code\',{pre:true},[_vm._v("POP()")])])])])]),_vm._v(" "),_c(\'h2\',[_vm._v("Applications")]),_vm._v(" "),_c(\'ul\',[_c(\'li\',[_vm._v("Reversing a string")]),_vm._v(" "),_c(\'li\',[_vm._v("Convert an infix expression to postfix")])]),_vm._v(" "),_c(\'h2\',[_vm._v("Methods")]),_vm._v(" "),_c(\'h3\',[_vm._v("Push")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("TOP = -1  // stack is empty\\ninput item\\n\\nif (TOP == N-1) then\\n  print \\"OVERFLOW\\"\\nelse\\n  top = TOP + 1\\n  STACK[TOP] = item\\nend if\\n")])]),_vm._v(" "),_c(\'p\',[_c(\'strong\',[_vm._v("Overflow")]),_vm._v(" is when the stack is full and an element is being pushed.")]),_vm._v(" "),_c(\'h3\',[_vm._v("Pop")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("TOP = 0  // no value for top as stack is empty\\nif (TOP < 1) then\\n  print \\"UNDERFLOW\\"\\nelse\\n  print STACK[TOP]\\n  TOP = TOP -1\\n  // return value and remove index\\nend if\\n")])]),_vm._v(" "),_c(\'p\',[_c(\'strong\',[_vm._v("Underflow")]),_vm._v(" is when the stack is empty but an element is being popped.")]),_vm._v(" "),_c(\'h3\',[_vm._v("Peek")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("begin procedure PEEK\\n  return stack[TOP]\\nend procedure\\n")])]),_vm._v(" "),_c(\'h1\',[_vm._v("Queue")]),_vm._v(" "),_c(\'ul\',[_c(\'li\',[_vm._v("FIFO: first in, first out\\n"),_c(\'ul\',[_c(\'li\',[_vm._v("All "),_c(\'strong\',[_vm._v("insertions")]),_vm._v(" take place at the "),_c(\'strong\',[_vm._v("rear")]),_vm._v(", and all "),_c(\'strong\',[_vm._v("deletions")]),_vm._v(" take place at the "),_c(\'strong\',[_vm._v("front")])])])]),_vm._v(" "),_c(\'li\',[_vm._v("Two pointers:\\n"),_c(\'ul\',[_c(\'li\',[_c(\'code\',{pre:true},[_vm._v("FRONT")]),_vm._v(" returns the first value")]),_vm._v(" "),_c(\'li\',[_c(\'code\',{pre:true},[_vm._v("REAR")]),_vm._v(" returns the last value")])])]),_vm._v(" "),_c(\'li\',[_vm._v("Top pointer points to first element: "),_c(\'code\',{pre:true},[_vm._v("PEEK() => QUEUE[FRONT]")])]),_vm._v(" "),_c(\'li\',[_vm._v("Two methods:\\n"),_c(\'ul\',[_c(\'li\',[_c(\'code\',{pre:true},[_vm._v("ENQUEUE()")])]),_vm._v(" "),_c(\'li\',[_c(\'code\',{pre:true},[_vm._v("DEQUE()")])])])]),_vm._v(" "),_c(\'li\',[_vm._v("When a value is dequeued, the value of "),_c(\'code\',{pre:true},[_vm._v("FRONT()")]),_vm._v(" changes, and there is a "),_c(\'em\',[_vm._v("vacant")]),_vm._v(" space left (and the value is returned)")])]),_vm._v(" "),_c(\'h2\',[_vm._v("Methods")]),_vm._v(" "),_c(\'h3\',[_vm._v("Enqueue")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("begin procedure ENQUEUE(DATA)\\n  if QUEUE.isFull() then\\n    return \\"OVERFLOW\\"\\n    exit\\n  end if\\n  REAR = REAR + 1\\n  QUEUE[REAR] = DATA\\nend procedure\\n")])]),_vm._v(" "),_c(\'h3\',[_vm._v("Dequeue")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("begin procedure DEQUEUE\\n  if QUEUE.isEmpty() then\\n    return \\"UNDERFLOW\\"\\n    exit\\n  end if\\n  DATA = QUEUE[FRONT]\\n  FRONT = FRONT + 1  \\n  // the front value is changed\\n  // although the data still exists in the memory, it is not in the queue\\n  return DATA\\nend procedure\\n")])]),_vm._v(" "),_c(\'h3\',[_vm._v("isFull")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("begin procedure isFull\\n  if (REAR == MAXSIZE) then  // max size is N - 1\\n    return true\\n  else\\n    return false\\n  end if\\nend procedure\\n")])]),_vm._v(" "),_c(\'h3\',[_vm._v("isEmpty")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("begin procedure isEmpty\\n  if (FONT < MINSIZE) OR (FRONT > REAR) then\\n    return true\\n  else\\n    return false\\n  end if\\nend procedure\\n")])]),_vm._v(" "),_c(\'h3\',[_vm._v("Peek")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true},[_vm._v("begin procedure PEEK\\n  return QUEUE[FRONT]\\nend procedure\\n")])])]) }]',component:{data:{},render:{},created:{}}}}})}],error:null,serverRendered:!0}</script><script src="/_nuxt/1e988892887ae859b600.js" defer></script><script src="/_nuxt/4f0ee4642ae49a7a05b4.js" defer></script><script src="/_nuxt/895579458ca7731cf8ea.js" defer></script><script src="/_nuxt/17e24a4181effd624233.js" defer></script>
  </body>
</html>
